#!/usr/bin/env python
# license removed for brevity
import rospy
import math
import numpy
from geometry_msgs.msg import Vector3
import time

# Vector distance:
def distanceAB(a,b):
    d = Vector3()
    d.x = abs(b.x-a.x) 
    d.y = abs(b.y-a.y)
    d.z = abs(b.z-a.z)
    return d
# Vector magnitude:
def magnitude(v):
    return math.sqrt(v.x*v.x + v.y*v.y + v.z*v.z)

pub = rospy.Publisher('desP', Vector3, queue_size=10)

i = 0

pointA = Vector3()
pointB = Vector3()

def callback(data):
    steps = 20
    global i
    i += 1
    print("entered interp callback with i=", i)
    if i == 1:
        global pointA
        pointA = data
        pub.publish(pointA)
    else: 
        global pointB
        pointB = data
        d = distanceAB(pointA, pointB)
        if d.x == 0 and d.y == 0 and d.z == 0:
            pointA = pointB
            pub.publish(pointA)
        else:
            for s in range(1,steps+1):
                P = Vector3()

                if pointA.x < pointB.x:
                    P.x = pointA.x + d.x/steps #* d/magnitude(d)
                else:
                    P.x = pointA.x - d.x/steps  #* d/magnitude(d)

                if pointA.y < pointB.y:
                    P.y = pointA.y + d.y/steps  #* d/magnitude(d)
                else:
                    P.y = pointA.y - d.y/steps  #* d/magnitude(d)

                if pointA.z < pointB.z:
                    P.z = pointA.z + d.z/steps  #* d/magnitude(d)
                else:
                    P.z = pointA.z - d.z/steps # * d/magnitude(d)
                pub.publish(P)
                pointA = P
                s += 1
                time.sleep(0.2)


def listener():
    rospy.init_node('interpP', anonymous=True)
    rospy.Subscriber("desP_nointerp", Vector3, callback)
    rospy.spin()

if __name__ == '__main__':
    listener()
